<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>3D 物理沙漏模拟器</title>
  <style>
    :root {
      color-scheme: dark;
      --bg0: #05070d;
      --bg1: #131a2b;
      --glass: rgba(170, 210, 255, 0.12);
      --accent: #ffcd73;
      --panel: rgba(10, 15, 26, 0.68);
      --border: rgba(180, 210, 255, 0.25);
      --text: #f6f9ff;
      --muted: #c7d5ec;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 20% 20%, #1b2745 0%, var(--bg1) 34%, var(--bg0) 100%);
      color: var(--text);
      font-family: "Inter", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      touch-action: none;
    }

    #app {
      position: fixed;
      inset: 0;
    }

    .hud {
      position: fixed;
      top: calc(12px + var(--safe-top));
      left: 12px;
      right: 12px;
      display: grid;
      gap: 10px;
      pointer-events: none;
    }

    .panel {
      width: min(92vw, 520px);
      backdrop-filter: blur(12px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px 14px;
      box-shadow: 0 10px 34px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }

    .title {
      margin: 0;
      font-size: clamp(14px, 2.8vw, 18px);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .subtitle {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: clamp(12px, 2.6vw, 14px);
      line-height: 1.45;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.06));
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
      padding: 9px 14px;
      cursor: pointer;
      min-height: 40px;
    }

    button:active {
      transform: scale(0.98);
    }

    .control {
      display: grid;
      gap: 4px;
      flex: 1;
      min-width: 180px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
      min-height: 26px;
    }

    .badge {
      padding: 2px 8px;
      font-size: 12px;
      color: #221203;
      background: linear-gradient(140deg, #ffd79d, #ffb03c);
      border-radius: 999px;
      font-weight: 700;
      justify-self: start;
    }

    .tip {
      position: fixed;
      left: 50%;
      bottom: calc(10px + var(--safe-bottom));
      transform: translateX(-50%);
      width: min(92vw, 520px);
      text-align: center;
      color: rgba(232, 240, 255, 0.86);
      font-size: 12px;
      background: rgba(10, 14, 24, 0.45);
      border: 1px solid rgba(200, 225, 255, 0.2);
      border-radius: 999px;
      padding: 8px 14px;
      backdrop-filter: blur(8px);
      pointer-events: none;
    }

    @media (max-width: 620px) {
      .panel {
        width: 100%;
      }

      .row {
        gap: 8px;
      }

      button {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <main id="app" aria-label="3D沙漏模拟器"></main>

  <div class="hud">
    <section class="panel" aria-label="控制面板">
      <h1 class="title">3D 物理沙漏模拟器</h1>
      <p class="subtitle">拖动旋转视角，点击翻转按钮即可手动翻面。支持触屏与鼠标操作，可实时调节沙粒数量。</p>
      <div class="row">
        <button id="flipButton" type="button">翻转沙漏</button>
        <div class="control">
          <label for="countSlider">沙粒数量：<span id="countLabel">1200</span></label>
          <input id="countSlider" type="range" min="300" max="3000" step="100" value="1200" />
        </div>
        <span class="badge" id="fpsBadge">-- FPS</span>
      </div>
    </section>
  </div>
  <p class="tip">iOS / Android / 桌面端兼容：优先使用 Pointer Events，并提供触摸回退与安全区适配。</p>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.164.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js';

    const app = document.getElementById('app');
    const flipButton = document.getElementById('flipButton');
    const countSlider = document.getElementById('countSlider');
    const countLabel = document.getElementById('countLabel');
    const fpsBadge = document.getElementById('fpsBadge');

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x060a14, 8, 22);

    const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.05, 60);
    camera.position.set(0, 1.35, 4.4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.minDistance = 2.1;
    controls.maxDistance = 7.2;
    controls.target.set(0, 0.2, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const hemi = new THREE.HemisphereLight(0xcde2ff, 0x372715, 0.9);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0xfff2dd, 1.2);
    keyLight.position.set(3.5, 5.5, 4);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x89bcff, 0.42);
    fillLight.position.set(-4, 2, -2);
    scene.add(fillLight);

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(8, 64),
      new THREE.MeshStandardMaterial({ color: 0x0e1524, metalness: 0.25, roughness: 0.72 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2.1;
    floor.receiveShadow = true;
    scene.add(floor);

    const hourglassRoot = new THREE.Group();
    scene.add(hourglassRoot);

    const glassMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x95d2ff,
      transparent: true,
      transmission: 0.96,
      opacity: 0.2,
      roughness: 0.03,
      metalness: 0.0,
      thickness: 0.5,
      envMapIntensity: 1.1,
      side: THREE.DoubleSide,
      reflectivity: 0.6,
      clearcoat: 1
    });

    function buildHourglassShell() {
      const points = [];
      const H = 1.55;
      for (let i = 0; i <= 48; i++) {
        const y = -H + (i / 48) * (2 * H);
        const neckInfluence = Math.exp(-Math.pow(y / 0.3, 2));
        const edge = Math.pow(Math.abs(y) / H, 1.5);
        const r = THREE.MathUtils.clamp(0.16 + edge * 0.86 - neckInfluence * 0.08, 0.12, 1.03);
        points.push(new THREE.Vector2(r, y));
      }
      const lathe = new THREE.LatheGeometry(points, 96);
      return new THREE.Mesh(lathe, glassMaterial);
    }

    const shell = buildHourglassShell();
    shell.castShadow = true;
    hourglassRoot.add(shell);

    const frameMat = new THREE.MeshStandardMaterial({ color: 0x68472c, roughness: 0.72, metalness: 0.1 });
    const ringGeo = new THREE.TorusGeometry(1.02, 0.06, 22, 90);
    const topRing = new THREE.Mesh(ringGeo, frameMat);
    topRing.position.y = 1.62;
    topRing.rotation.x = Math.PI / 2;
    const bottomRing = topRing.clone();
    bottomRing.position.y = -1.62;
    hourglassRoot.add(topRing, bottomRing);

    const postGeo = new THREE.CylinderGeometry(0.055, 0.055, 3.2, 24);
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * Math.PI * 2;
      const post = new THREE.Mesh(postGeo, frameMat);
      post.position.set(Math.cos(angle) * 0.98, 0, Math.sin(angle) * 0.98);
      post.castShadow = true;
      hourglassRoot.add(post);
    }

    const sandMaterial = new THREE.MeshStandardMaterial({ color: 0xf5c778, roughness: 0.45, metalness: 0.05 });
    const grainRadius = 0.026;
    const grainGeo = new THREE.SphereGeometry(grainRadius, 10, 10);

    let particles = [];
    let instanced;

    const bounds = {
      minY: -1.46,
      maxY: 1.46,
      neckY: 0,
      neckRadius: 0.095,
      maxRadius: 0.96,
      throatHalfHeight: 0.18
    };

    let gravitySign = -1;
    let flipTarget = 0;
    let flipCurrent = 0;

    const tmpMatrix = new THREE.Matrix4();
    const tmpQuat = new THREE.Quaternion();
    const tmpScale = new THREE.Vector3(1, 1, 1);

    function radiusAt(y) {
      const H = 1.55;
      const neckInfluence = Math.exp(-Math.pow(y / 0.3, 2));
      const edge = Math.pow(Math.abs(y) / H, 1.5);
      return THREE.MathUtils.clamp(0.16 + edge * 0.86 - neckInfluence * 0.08, 0.12, 1.03);
    }

    function randomPointInUpperBulb() {
      for (let k = 0; k < 20; k++) {
        const y = THREE.MathUtils.randFloat(0.18, bounds.maxY - grainRadius * 2);
        const r = radiusAt(y) - grainRadius;
        const t = Math.random() * Math.PI * 2;
        const radial = Math.sqrt(Math.random()) * Math.max(r, 0.01);
        const x = Math.cos(t) * radial;
        const z = Math.sin(t) * radial;
        return new THREE.Vector3(x, y, z);
      }
      return new THREE.Vector3(0, 1, 0);
    }

    function resetParticles(count) {
      if (instanced) {
        scene.remove(instanced);
        instanced.geometry.dispose();
        instanced.material.dispose();
      }

      instanced = new THREE.InstancedMesh(grainGeo, sandMaterial.clone(), count);
      instanced.castShadow = true;
      scene.add(instanced);

      particles = Array.from({ length: count }, () => {
        const pos = randomPointInUpperBulb();
        return {
          p: pos,
          v: new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.04),
            THREE.MathUtils.randFloatSpread(0.03),
            THREE.MathUtils.randFloatSpread(0.04)
          )
        };
      });

      countLabel.textContent = String(count);
      updateInstances();
    }

    function updateInstances() {
      for (let i = 0; i < particles.length; i++) {
        tmpQuat.set(0, 0, 0, 1);
        tmpMatrix.compose(particles[i].p, tmpQuat, tmpScale);
        instanced.setMatrixAt(i, tmpMatrix);
      }
      instanced.instanceMatrix.needsUpdate = true;
    }

    function constrainParticle(part) {
      const pos = part.p;
      const vel = part.v;

      if (pos.y > bounds.maxY) {
        pos.y = bounds.maxY;
        vel.y *= -0.22;
      }
      if (pos.y < bounds.minY) {
        pos.y = bounds.minY;
        vel.y *= -0.22;
      }

      const allowedR = Math.max(radiusAt(pos.y) - grainRadius, 0.04);
      const radial = Math.hypot(pos.x, pos.z);

      const nearNeck = Math.abs(pos.y - bounds.neckY) < bounds.throatHalfHeight;
      const neckCap = bounds.neckRadius - grainRadius * 0.3;
      const tunnelR = nearNeck ? Math.min(allowedR, neckCap) : allowedR;

      if (radial > tunnelR) {
        const nx = pos.x / (radial || 1);
        const nz = pos.z / (radial || 1);
        pos.x = nx * tunnelR;
        pos.z = nz * tunnelR;

        const dot = vel.x * nx + vel.z * nz;
        vel.x -= dot * nx * 1.35;
        vel.z -= dot * nz * 1.35;
      }
    }

    function simulate(dt) {
      const g = -5.9 * gravitySign;
      for (let i = 0; i < particles.length; i++) {
        const part = particles[i];
        part.v.y += g * dt;

        part.v.multiplyScalar(0.9965);
        part.p.addScaledVector(part.v, dt);

        constrainParticle(part);
      }

      // 低成本近邻扰动，模拟沙堆摩擦与散开
      for (let i = 0; i < particles.length; i += 3) {
        const a = particles[i];
        const j = (i * 13 + 17) % particles.length;
        const b = particles[j];
        const dx = a.p.x - b.p.x;
        const dy = a.p.y - b.p.y;
        const dz = a.p.z - b.p.z;
        const d2 = dx * dx + dy * dy + dz * dz;
        const minD = grainRadius * 1.7;
        if (d2 > 0.000001 && d2 < minD * minD) {
          const d = Math.sqrt(d2);
          const push = (minD - d) * 0.18;
          const nx = dx / d;
          const ny = dy / d;
          const nz = dz / d;
          a.p.x += nx * push;
          a.p.y += ny * push;
          a.p.z += nz * push;
          b.p.x -= nx * push;
          b.p.y -= ny * push;
          b.p.z -= nz * push;
        }
      }
    }

    function onFlip() {
      gravitySign *= -1;
      flipTarget += Math.PI;
    }

    flipButton.addEventListener('click', onFlip);

    let sliderTimer;
    countSlider.addEventListener('input', (e) => {
      const value = Number(e.target.value);
      countLabel.textContent = String(value);
      clearTimeout(sliderTimer);
      sliderTimer = setTimeout(() => resetParticles(value), 120);
    });

    // iOS Safari fallback
    renderer.domElement.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(w, h);
    }

    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', () => setTimeout(onResize, 180));

    let lastT = performance.now();
    let fpsCounter = { frames: 0, elapsed: 0 };

    function animate(t) {
      requestAnimationFrame(animate);
      const dt = Math.min((t - lastT) / 1000, 0.033);
      lastT = t;

      simulate(dt);
      flipCurrent = THREE.MathUtils.lerp(flipCurrent, flipTarget, 0.12);
      hourglassRoot.rotation.z = flipCurrent;

      updateInstances();
      controls.update();
      renderer.render(scene, camera);

      fpsCounter.frames++;
      fpsCounter.elapsed += dt;
      if (fpsCounter.elapsed > 0.35) {
        const fps = Math.round(fpsCounter.frames / fpsCounter.elapsed);
        fpsBadge.textContent = `${fps} FPS`;
        fpsCounter.frames = 0;
        fpsCounter.elapsed = 0;
      }
    }

    resetParticles(Number(countSlider.value));
    animate(performance.now());
  </script>
</body>
</html>
