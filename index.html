<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D 物理沙漏模拟器</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0c0f1a;
      --panel: rgba(14, 18, 30, 0.85);
      --accent: #88d1ff;
      --accent-2: #f6d365;
      --text: #eef4ff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: "Inter", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1a2242 0%, #0b0f1b 55%, #06070c 100%);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-columns: minmax(240px, 320px) 1fr;
      gap: 24px;
      height: 100vh;
      padding: 24px;
    }

    @media (max-width: 960px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        padding: 16px;
      }
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(136, 209, 255, 0.2);
      border-radius: 20px;
      padding: 20px;
      backdrop-filter: blur(12px);
      box-shadow: 0 24px 40px rgba(0, 0, 0, 0.35);
    }

    .panel h1 {
      font-size: 22px;
      margin-bottom: 12px;
    }

    .panel p {
      font-size: 14px;
      line-height: 1.6;
      color: rgba(238, 244, 255, 0.8);
      margin-bottom: 18px;
    }

    .control-group {
      margin-bottom: 18px;
    }

    label {
      font-size: 13px;
      display: block;
      margin-bottom: 8px;
      color: rgba(238, 244, 255, 0.8);
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .value {
      font-size: 13px;
      margin-top: 6px;
      color: rgba(246, 211, 101, 0.9);
    }

    button {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #3fb8ff, #8de1ff);
      color: #0c0f1a;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:active {
      transform: scale(0.98);
      box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
    }

    .canvas-wrap {
      position: relative;
      border-radius: 24px;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(18, 24, 40, 0.9), rgba(7, 9, 18, 0.95));
      border: 1px solid rgba(136, 209, 255, 0.15);
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.4), 0 18px 40px rgba(0, 0, 0, 0.5);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .hint {
      position: absolute;
      bottom: 18px;
      left: 18px;
      right: 18px;
      font-size: 12px;
      line-height: 1.6;
      color: rgba(238, 244, 255, 0.7);
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="panel">
      <h1>3D 物理沙漏模拟器</h1>
      <p>点击或触摸「翻转沙漏」即可手动翻转。滑动滑块调整沙粒数量，系统会自动重新生成沙粒并保持平滑的物理效果。</p>
      <div class="control-group">
        <label for="sandCount">沙粒数量</label>
        <input id="sandCount" type="range" min="200" max="1200" value="700" />
        <div class="value">当前：<span id="sandValue">700</span> 颗</div>
      </div>
      <div class="control-group">
        <button id="flipBtn">翻转沙漏</button>
      </div>
      <p>兼容桌面与移动端（包含 iOS）。如果设备性能有限，建议减少沙粒数量。</p>
    </section>

    <section class="canvas-wrap">
      <canvas id="scene"></canvas>
      <div class="hint">拖动屏幕可轻微旋转视角；双击或双指轻触翻转沙漏。</div>
    </section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <script>
    const canvas = document.getElementById("scene");
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: "high-performance",
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0d18, 6, 18);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 3.6, 10.5);

    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);

    const spot = new THREE.SpotLight(0x88d1ff, 1.2, 30, Math.PI / 6, 0.4, 1);
    spot.position.set(5, 10, 6);
    scene.add(spot);

    const rim = new THREE.PointLight(0xf6d365, 0.8, 18);
    rim.position.set(-5, -2, 4);
    scene.add(rim);

    const glassMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x89c5ff,
      metalness: 0.1,
      roughness: 0.05,
      transmission: 0.9,
      thickness: 0.8,
      transparent: true,
      opacity: 0.45,
      clearcoat: 0.4,
    });

    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x1b2b45,
      metalness: 0.5,
      roughness: 0.4,
    });

    const sandMaterial = new THREE.MeshStandardMaterial({
      color: 0xf6d365,
      roughness: 0.6,
      metalness: 0.05,
      emissive: 0x140f02,
    });

    const hourglass = new THREE.Group();
    scene.add(hourglass);

    const upperCone = new THREE.Mesh(new THREE.ConeGeometry(2.1, 4, 64, 1, true), glassMaterial);
    upperCone.position.y = 1.6;
    upperCone.rotation.x = Math.PI;
    hourglass.add(upperCone);

    const lowerCone = new THREE.Mesh(new THREE.ConeGeometry(2.1, 4, 64, 1, true), glassMaterial);
    lowerCone.position.y = -1.6;
    hourglass.add(lowerCone);

    const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 0.8, 32), glassMaterial);
    hourglass.add(neck);

    const topFrame = new THREE.Mesh(new THREE.CylinderGeometry(2.3, 2.3, 0.3, 48), frameMaterial);
    topFrame.position.y = 3.1;
    hourglass.add(topFrame);

    const bottomFrame = new THREE.Mesh(new THREE.CylinderGeometry(2.3, 2.3, 0.3, 48), frameMaterial);
    bottomFrame.position.y = -3.1;
    hourglass.add(bottomFrame);

    const pillarGeometry = new THREE.CylinderGeometry(0.12, 0.12, 6.2, 16);
    const pillarOffsets = [
      [2.1, 0, 0],
      [-2.1, 0, 0],
      [0, 0, 2.1],
      [0, 0, -2.1],
    ];
    pillarOffsets.forEach(([x, y, z]) => {
      const pillar = new THREE.Mesh(pillarGeometry, frameMaterial);
      pillar.position.set(x, y, z);
      hourglass.add(pillar);
    });

    const sandGroup = new THREE.Group();
    hourglass.add(sandGroup);

    let particleCount = 700;
    let particles = [];
    let gravity = -0.015;
    let flipProgress = 0;
    let flipping = false;

    const sandGeometry = new THREE.SphereGeometry(0.05, 8, 8);

    function randomPointInCone(isUpper) {
      const height = 3.6;
      const radius = 2.0;
      const y = Math.random() * height;
      const localRadius = (1 - y / height) * radius;
      const theta = Math.random() * Math.PI * 2;
      const r = Math.random() * localRadius;
      const x = Math.cos(theta) * r;
      const z = Math.sin(theta) * r;
      return {
        x,
        y: isUpper ? y + 0.2 : -y - 0.2,
        z,
      };
    }

    function seedParticles(count) {
      particles.forEach((particle) => sandGroup.remove(particle.mesh));
      particles = [];
      for (let i = 0; i < count; i += 1) {
        const mesh = new THREE.Mesh(sandGeometry, sandMaterial);
        const pos = randomPointInCone(true);
        mesh.position.set(pos.x, pos.y, pos.z);
        sandGroup.add(mesh);
        particles.push({
          mesh,
          velocity: new THREE.Vector3(0, 0, 0),
        });
      }
    }

    function clampToCone(particle) {
      const pos = particle.mesh.position;
      const upper = pos.y > 0;
      const height = 3.6;
      const radius = 2.0;
      const localY = upper ? pos.y - 0.2 : -pos.y - 0.2;
      const maxRadius = Math.max(0.2, (1 - localY / height) * radius);
      const dist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
      if (dist > maxRadius) {
        const scale = maxRadius / dist;
        pos.x *= scale;
        pos.z *= scale;
      }
    }

    function updateParticles() {
      const neckRadius = 0.25;
      const settleY = gravity < 0 ? -3.2 : 3.2;
      particles.forEach((particle) => {
        const vel = particle.velocity;
        vel.y += gravity;
        particle.mesh.position.add(vel);

        if (Math.abs(particle.mesh.position.y) < 0.5) {
          const dist = Math.sqrt(
            particle.mesh.position.x ** 2 + particle.mesh.position.z ** 2
          );
          if (dist > neckRadius) {
            vel.x *= -0.6;
            vel.z *= -0.6;
            particle.mesh.position.x *= neckRadius / dist;
            particle.mesh.position.z *= neckRadius / dist;
          }
        }

        clampToCone(particle);

        if ((gravity < 0 && particle.mesh.position.y < settleY) ||
            (gravity > 0 && particle.mesh.position.y > settleY)) {
          particle.mesh.position.y = settleY + (Math.random() - 0.5) * 0.05;
          vel.set((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01);
        }
      });
    }

    function resize() {
      const { clientWidth, clientHeight } = canvas.parentElement;
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }

    window.addEventListener("resize", resize);
    resize();

    let rotationTarget = 0;
    let dragActive = false;
    let lastPointerX = 0;

    function onPointerDown(event) {
      dragActive = true;
      lastPointerX = event.clientX || event.touches?.[0]?.clientX || 0;
    }

    function onPointerMove(event) {
      if (!dragActive) return;
      const clientX = event.clientX || event.touches?.[0]?.clientX || 0;
      const delta = (clientX - lastPointerX) / 200;
      lastPointerX = clientX;
      rotationTarget += delta;
    }

    function onPointerUp() {
      dragActive = false;
    }

    canvas.addEventListener("mousedown", onPointerDown);
    canvas.addEventListener("mousemove", onPointerMove);
    canvas.addEventListener("mouseup", onPointerUp);
    canvas.addEventListener("mouseleave", onPointerUp);
    canvas.addEventListener("touchstart", onPointerDown, { passive: true });
    canvas.addEventListener("touchmove", onPointerMove, { passive: true });
    canvas.addEventListener("touchend", onPointerUp);

    const flipBtn = document.getElementById("flipBtn");
    flipBtn.addEventListener("click", triggerFlip);
    canvas.addEventListener("dblclick", triggerFlip);
    canvas.addEventListener("touchend", (event) => {
      if (event.touches.length === 0 && event.changedTouches.length === 2) {
        triggerFlip();
      }
    });

    function triggerFlip() {
      if (flipping) return;
      flipping = true;
      flipProgress = 0;
    }

    const sandCount = document.getElementById("sandCount");
    const sandValue = document.getElementById("sandValue");
    sandCount.addEventListener("input", (event) => {
      particleCount = Number(event.target.value);
      sandValue.textContent = particleCount;
      seedParticles(particleCount);
    });

    seedParticles(particleCount);

    function animate() {
      requestAnimationFrame(animate);
      updateParticles();
      if (flipping) {
        flipProgress += 0.02;
        hourglass.rotation.z = Math.sin(Math.min(flipProgress, Math.PI)) * Math.PI;
        if (flipProgress >= Math.PI) {
          flipping = false;
          hourglass.rotation.z = 0;
          gravity *= -1;
        }
      }
      hourglass.rotation.y += (rotationTarget - hourglass.rotation.y) * 0.05;
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
